<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>SwiftyHTTP by AlwaysRightInstitute</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">SwiftyHTTP</h1>
      <h2 class="project-tagline">A simple GCD based HTTP client and server, written in &#39;pure&#39; Swift</h2>
      <a href="https://github.com/AlwaysRightInstitute/SwiftyHTTP" class="btn">View on GitHub</a>
      <a href="https://github.com/AlwaysRightInstitute/SwiftyHTTP/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/AlwaysRightInstitute/SwiftyHTTP/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="swiftyhttp" class="anchor" href="#swiftyhttp" aria-hidden="true"><span class="octicon octicon-link"></span></a>SwiftyHTTP</h1>

<p>A simple GCD based HTTP library for Swift. This project is 'pure' Swift/C,
it does not use any bridged Objective-C classes.</p>

<p>SwiftyHTTP is a demo on how to integrate Swift with raw C APIs. More
for stealing Swift coding ideas than for actually using the code in a real
project. In most real world Swift apps you have access to Cocoa, use it.</p>

<p><strong>Note</strong>: This is just my second <a href="https://developer.apple.com/swift/">Swift</a>
project. Any suggestions on how to improve the code are welcome. I expect
lots and lots :-)</p>

<h3>
<a id="first-things-first-samples" class="anchor" href="#first-things-first-samples" aria-hidden="true"><span class="octicon octicon-link"></span></a>First things first: Samples</h3>

<p>Server:</p>

<div class="highlight highlight-Swift"><pre><span class="pl-k">let</span> httpd <span class="pl-k">=</span> HTTPServer()
  <span class="pl-k">.</span>onRequest {
    rq, res, con <span class="pl-k">in</span>
    res<span class="pl-k">.</span>bodyAsString <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>&lt;h2&gt;Always Right, Never Wrong!&lt;/h2&gt;<span class="pl-pds">"</span></span>
    con<span class="pl-k">.</span>sendResponse(res)
  }
  <span class="pl-k">.</span>listen(<span class="pl-c1">1337</span>)</pre></div>

<p>Server using the Node.JS like Connect bonus class:</p>

<div class="highlight highlight-Swift"><pre><span class="pl-k">let</span> httpd <span class="pl-k">=</span> Connect()
  <span class="pl-k">.</span>use { rq, res, _, next <span class="pl-k">in</span>
    println(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1">rq<span class="pl-k">.</span>method</span><span class="pl-pse">)</span> <span class="pl-pse">\(</span><span class="pl-s1">rq<span class="pl-k">.</span>url</span><span class="pl-pse">)</span> <span class="pl-pse">\(</span><span class="pl-s1">res<span class="pl-k">.</span>status</span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>)
    next()
  }
  <span class="pl-k">.</span>use(<span class="pl-s"><span class="pl-pds">"</span>/hello<span class="pl-pds">"</span></span>) { rq, res, con, next <span class="pl-k">in</span>
    res<span class="pl-k">.</span>bodyAsString <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Hello!<span class="pl-pds">"</span></span>
    con<span class="pl-k">.</span>sendResponse(res)
  }
  <span class="pl-k">.</span>use(<span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span>) { rq, res, con, next <span class="pl-k">in</span>
    res<span class="pl-k">.</span>bodyAsString <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Always, almost sometimes.<span class="pl-pds">"</span></span>
    con<span class="pl-k">.</span>sendResponse(res)
  }
  <span class="pl-k">.</span>listen(<span class="pl-c1">1337</span>)</pre></div>

<p>Client (do not use this, use NSURLSession!):</p>

<div class="highlight highlight-Swift"><pre>GET(<span class="pl-s"><span class="pl-pds">"</span>http://www.apple.com/<span class="pl-pds">"</span></span>)
  <span class="pl-k">.</span>done {
    println()
    println(<span class="pl-s"><span class="pl-pds">"</span>request  <span class="pl-pse">\(</span><span class="pl-s1">$<span class="pl-c1">0</span></span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>)
    println(<span class="pl-s"><span class="pl-pds">"</span>response <span class="pl-pse">\(</span><span class="pl-s1">$<span class="pl-c1">1</span></span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>)
    println(<span class="pl-s"><span class="pl-pds">"</span>body:<span class="pl-cce">\n</span><span class="pl-pse">\(</span><span class="pl-s1">$<span class="pl-c1">1</span><span class="pl-k">.</span>bodyAsString</span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>)
  }
  <span class="pl-k">.</span>fail {
    println(<span class="pl-s"><span class="pl-pds">"</span>failed <span class="pl-pse">\(</span><span class="pl-s1">$<span class="pl-c1">0</span></span><span class="pl-pse">)</span>: <span class="pl-pse">\(</span><span class="pl-s1">$<span class="pl-c1">1</span></span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>)
  }
  <span class="pl-k">.</span>always { println(<span class="pl-s"><span class="pl-pds">"</span>---<span class="pl-pds">"</span></span>) }</pre></div>

<h3>
<a id="targets" class="anchor" href="#targets" aria-hidden="true"><span class="octicon octicon-link"></span></a>Targets</h3>

<p>Updated to use Swift v0.2 (aka Xcode 6.3).</p>

<p>The project includes three targets:</p>

<ul>
<li>SwiftyHTTP</li>
<li>SwiftyServer</li>
<li>SwiftyClient</li>
</ul>

<p>I suggest you start out looking at the SwiftyServer.</p>

<h4>
<a id="swiftyhttp-1" class="anchor" href="#swiftyhttp-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>SwiftyHTTP</h4>

<p>A framework containing the HTTP classes and relevant extensions. It has a few
'subprojects':</p>

<ul>
<li>Foundation</li>
<li>Sockets</li>
<li>Parser</li>
<li>HTTP</li>
</ul>

<h5>
<a id="foundation" class="anchor" href="#foundation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Foundation</h5>

<p>This has just the 'RawByteBuffer' class. Which is kinda like a RawByte array.
I bet there are better ways to implement this! Please suggest some! :-)</p>

<p>Also a few - highly inefficient - extensions to convert between String's and
CString's. I would love some suggestions on those as well.</p>

<p>But remember: NSxyz is forbidden for this venture! :-)</p>

<h5>
<a id="sockets" class="anchor" href="#sockets" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sockets</h5>

<p>Just a local copy of the SwiftSockets project - I wish GIT had proper externals
;-) (<a href="https://github.com/AlwaysRightInstitute/SwiftSockets">https://github.com/AlwaysRightInstitute/SwiftSockets</a>)</p>

<h5>
<a id="parser" class="anchor" href="#parser" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parser</h5>

<p>This uses the C HTTP parser which is also used in Node.JS. I couldn't
directly use it being C callback driven - a feature (currently?)
unsupported by Swift.
The fix was to rewrite the parser to use C blocks instead of function pointers.
Along that way I also removed some great features of the parser, like no
malloc() at all :-&gt;</p>

<p>It also contains the main request/response classes: HTTPRequest and
HTTPResponse, both subclasses of HTTPMessage.
And enums for HTTP status values (like <code>💰Required</code>) and request methods (GET
etc).</p>

<h5>
<a id="http" class="anchor" href="#http" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP</h5>

<p>HTTPConnectionPool is an abstract base class and manages open connections,
either incoming or outgoing. The HTTPConnection sits on top of the SwiftSockets
and manages one HTTP connection (it connects the socket to the parser).</p>

<p>HTTPServer is the server class. Uses SwiftSockets to listen for incoming
connections. See above for a sample.</p>

<p>As a bonus - this also has a tiny Connect class - which is modelled after the
Node.JS Connect thingy (which in turn is apparently modelled after RoR Rack).
It allows you to hook up a set of blocks for request processing, instead of
having just a single entry point.
Not sure I like that stuff, but it seems to fit into Swift quite well.
Find a sample above.</p>

<p>Finally there is a simple HTTP client. Doesn't do anything fancy. Do not - ever</p>

<ul>
<li>use this. Use NSURLSession and companions.</li>
</ul>

<h4>
<a id="swiftyserver" class="anchor" href="#swiftyserver" aria-hidden="true"><span class="octicon octicon-link"></span></a>SwiftyServer</h4>

<p>Great httpd server - great in counting the requests it got sent. This is not
actually serving any files ;-) Comes along as a Cocoa app. Compile it, run it,
then connect to it in the browser via <a href="http://127.0.0.1:1337/Awesome-O">http://127.0.0.1:1337/Awesome-O</a>!</p>

<p><img src="http://i.imgur.com/4ShGZXS.png" alt=""></p>

<h4>
<a id="swiftyclient" class="anchor" href="#swiftyclient" aria-hidden="true"><span class="octicon octicon-link"></span></a>SwiftyClient</h4>

<p>Just a demo on how to do HTTP requests via SwiftyHTTP. No, it doesn't do JSON
decoding and such.</p>

<p>Again: You do NOT want to use it in a real iOS/OSX app! Use NSURLSession and
companions - it gives you plenty of extra features you want to have for realz.</p>

<p><img src="http://i.imgur.com/ny0PSKH.png" alt=""></p>

<h3>
<a id="goals" class="anchor" href="#goals" aria-hidden="true"><span class="octicon octicon-link"></span></a>Goals</h3>

<ul>
<li>[x] Max line length: 80 characters</li>
<li>[ ] Great error handling

<ul>
<li>[x] PS style great error handling</li>
<li>[x] println() error handling</li>
<li>[ ] Real error handling</li>
</ul>
</li>
<li>[x] Twisted (no blocking reads or writes)

<ul>
<li>[x] Async reads and writes

<ul>
<li>[x] Never block on reads</li>
<li>[x] Never block on listen</li>
</ul>
</li>
<li>[ ] Async connect()</li>
</ul>
</li>
<li>[x] No NS'ism</li>
<li>[ ] Use as many language features Swift provides

<ul>
<li>[x] Generics

<ul>
<li>[x] Generic function</li>
<li>[x] typealias</li>
</ul>
</li>
<li>[x] Closures

<ul>
<li>[x] weak self</li>
<li>[x] trailing closures</li>
<li>[x] implicit parameters</li>
</ul>
</li>
<li>[x] Unowned</li>
<li>[x] Extensions on structs</li>
<li>[x] Extensions to organize classes</li>
<li>[x] Protocols on structs</li>
<li>[x] Tuples</li>
<li>[x] Trailing closures</li>
<li>[ ] <a href="https://github.com/Lazy" class="user-mention">@Lazy</a>
</li>
<li>[x] Pure Swift weak delegates via <a href="https://github.com/class" class="user-mention">@class</a>
</li>
<li>[x] Optionals

<ul>
<li>[x] Implicitly unwrapped optionals</li>
</ul>
</li>
<li>[x] Convenience initializers</li>
<li>[x] Class variables on structs</li>
<li>[x] CConstPointer, CConstVoidPointer

<ul>
<li>[x] withCString {}</li>
</ul>
</li>
<li>[x] UnsafePointer</li>
<li>[x] sizeof()</li>
<li>[x] Standard Protocols

<ul>
<li>[x] Printable</li>
<li>[x] BooleanType (aka LogicValue)</li>
<li>[x] OutputStreamType</li>
<li>[x] Equatable

<ul>
<li>[x] Equatable on Enums with Associated Values</li>
</ul>
</li>
<li>[x] Hashable</li>
<li>[x] SequenceType (GeneratorOf)</li>
<li>[x] Literal Convertibles

<ul>
<li>[x] StringLiteralConvertible</li>
<li>[x] IntegerLiteralConvertible</li>
</ul>
</li>
</ul>
</li>
<li>[x] Left shift AND right shift</li>
<li>[x] Enums on steroids

<ul>
<li>[x] RawRepresentable</li>
</ul>
</li>
<li>[ ] Dynamic type system, reflection</li>
<li>[x] Operator overloading</li>
<li>[x] UCS-4 identifiers (<g-emoji alias="chicken" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f414.png">🐔</g-emoji><g-emoji alias="chicken" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f414.png">🐔</g-emoji><g-emoji alias="chicken" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f414.png">🐔</g-emoji>)</li>
<li>[ ] <del>RTF source code with images and code sections in different fonts</del>
</li>
<li>[x] Nested classes/types</li>
<li>[ ] Patterns

<ul>
<li>[x] Use wildcard pattern to ignore value</li>
</ul>
</li>
<li>[ ] <a href="https://github.com/autoclosure" class="user-mention">@autoclosure</a>
</li>
<li>[ ] unsafeBitCast (was reinterpretCast)</li>
<li>[x] final</li>
<li>[x] Nil coalescing operator</li>
<li>[ ] dynamic</li>
</ul>
</li>
</ul>

<h3>
<a id="why" class="anchor" href="#why" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why?!</h3>

<p>This is an experiment to get acquainted with Swift. To check whether something
real can be implemented in 'pure' Swift. Meaning, without using any Objective-C
Cocoa classes (no NS'ism).
Or in other words: Can you use Swift without writing all the 'real' code in
wrapped Objective-C? :-)</p>

<h3>
<a id="contact" class="anchor" href="#contact" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contact</h3>

<p><a href="http://twitter.com/helje5">@helje5</a> | <a href="mailto:helge@alwaysrightinstitute.com">helge@alwaysrightinstitute.com</a></p>

<p><img src="http://www.alwaysrightinstitute.com/ARI.png" alt=""></p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/AlwaysRightInstitute/SwiftyHTTP">SwiftyHTTP</a> is maintained by <a href="https://github.com/AlwaysRightInstitute">AlwaysRightInstitute</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

