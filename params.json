{"name":"SwiftyHTTP","tagline":"A simple GCD based HTTP client and server, written in 'pure' Swift","body":"SwiftyHTTP\r\n==========\r\n\r\nA simple GCD based HTTP library for Swift. This project is 'pure' Swift/C,\r\nit does not use any bridged Objective-C classes.\r\n\r\nSwiftyHTTP is a demo on how to integrate Swift with raw C APIs. More\r\nfor stealing Swift coding ideas than for actually using the code in a real\r\nproject. In most real world Swift apps you have access to Cocoa, use it.\r\n\r\n**Note**: This is just my second [Swift](https://developer.apple.com/swift/)\r\nproject. Any suggestions on how to improve the code are welcome. I expect\r\nlots and lots :-)\r\n\r\n###First things first: Samples\r\n\r\nServer:\r\n```Swift\r\nlet httpd = HTTPServer()\r\n  .onRequest {\r\n    rq, res, con in\r\n    res.bodyAsString = \"<h2>Always Right, Never Wrong!</h2>\"\r\n    con.sendResponse(res)\r\n  }\r\n  .listen(1337)\r\n```\r\n\r\nServer using the Node.JS like Connect bonus class:\r\n```Swift\r\nlet httpd = Connect()\r\n  .use { rq, res, _, next in\r\n    println(\"\\(rq.method) \\(rq.url) \\(res.status)\")\r\n    next()\r\n  }\r\n  .use(\"/hello\") { rq, res, con, next in\r\n    res.bodyAsString = \"Hello!\"\r\n    con.sendResponse(res)\r\n  }\r\n  .use(\"/\") { rq, res, con, next in\r\n    res.bodyAsString = \"Always, almost sometimes.\"\r\n    con.sendResponse(res)\r\n  }\r\n  .listen(1337)\r\n```\r\n\r\nClient (do not use this, use NSURLSession!):\r\n```Swift\r\nGET(\"http://www.apple.com/\")\r\n  .done {\r\n    println()\r\n    println(\"request  \\($0)\")\r\n    println(\"response \\($1)\")\r\n    println(\"body:\\n\\($1.bodyAsString)\")\r\n  }\r\n  .fail {\r\n    println(\"failed \\($0): \\($1)\")\r\n  }\r\n  .always { println(\"---\") }\r\n```\r\n\r\n\r\n###Targets\r\n\r\nUpdated to use Swift v0.2 (aka Xcode 6.3).\r\n\r\nThe project includes three targets:\r\n- SwiftyHTTP\r\n- SwiftyServer\r\n- SwiftyClient\r\n\r\nI suggest you start out looking at the SwiftyServer.\r\n\r\n####SwiftyHTTP\r\n\r\nA framework containing the HTTP classes and relevant extensions. It has a few\r\n'subprojects':\r\n- Foundation\r\n- Sockets\r\n- Parser\r\n- HTTP\r\n\r\n#####Foundation\r\n\r\nThis has just the 'RawByteBuffer' class. Which is kinda like a RawByte array.\r\nI bet there are better ways to implement this! Please suggest some! :-)\r\n\r\nAlso a few - highly inefficient - extensions to convert between String's and\r\nCString's. I would love some suggestions on those as well.\r\n\r\nBut remember: NSxyz is forbidden for this venture! :-)\r\n\r\n#####Sockets\r\n\r\nJust a local copy of the SwiftSockets project - I wish GIT had proper externals\r\n;-) (https://github.com/AlwaysRightInstitute/SwiftSockets)\r\n\r\n#####Parser\r\n\r\nThis uses the C HTTP parser which is also used in Node.JS. I couldn't\r\ndirectly use it being C callback driven - a feature (currently?)\r\nunsupported by Swift.\r\nThe fix was to rewrite the parser to use C blocks instead of function pointers.\r\nAlong that way I also removed some great features of the parser, like no\r\nmalloc() at all :->\r\n\r\nIt also contains the main request/response classes: HTTPRequest and\r\nHTTPResponse, both subclasses of HTTPMessage.\r\nAnd enums for HTTP status values (like `üí∞Required`) and request methods (GET\r\netc).\r\n\r\n#####HTTP\r\n\r\nHTTPConnectionPool is an abstract base class and manages open connections,\r\neither incoming or outgoing. The HTTPConnection sits on top of the SwiftSockets\r\nand manages one HTTP connection (it connects the socket to the parser).\r\n\r\nHTTPServer is the server class. Uses SwiftSockets to listen for incoming\r\nconnections. See above for a sample.\r\n\r\nAs a bonus - this also has a tiny Connect class - which is modelled after the\r\nNode.JS Connect thingy (which in turn is apparently modelled after RoR Rack).\r\nIt allows you to hook up a set of blocks for request processing, instead of\r\nhaving just a single entry point.\r\nNot sure I like that stuff, but it seems to fit into Swift quite well.\r\nFind a sample above.\r\n\r\nFinally there is a simple HTTP client. Doesn't do anything fancy. Do not - ever\r\n- use this. Use NSURLSession and companions.\r\n\r\n####SwiftyServer\r\n\r\nGreat httpd server - great in counting the requests it got sent. This is not\r\nactually serving any files ;-) Comes along as a Cocoa app. Compile it, run it,\r\nthen connect to it in the browser via http://127.0.0.1:1337/Awesome-O!\r\n\r\n![](http://i.imgur.com/4ShGZXS.png)\r\n\r\n####SwiftyClient\r\n\r\nJust a demo on how to do HTTP requests via SwiftyHTTP. No, it doesn't do JSON\r\ndecoding and such.\r\n\r\nAgain: You do NOT want to use it in a real iOS/OSX app! Use NSURLSession and\r\ncompanions - it gives you plenty of extra features you want to have for realz.\r\n\r\n![](http://i.imgur.com/ny0PSKH.png)\r\n\r\n###Goals\r\n\r\n- [x] Max line length: 80 characters\r\n- [ ] Great error handling\r\n  - [x] PS style great error handling\r\n  - [x] println() error handling\r\n  - [ ] Real error handling\r\n- [x] Twisted (no blocking reads or writes)\r\n  - [x] Async reads and writes\r\n    - [x] Never block on reads\r\n    - [x] Never block on listen\r\n  - [ ] Async connect()\r\n- [x] No NS'ism\r\n- [ ] Use as many language features Swift provides\r\n  - [x] Generics\r\n    - [x] Generic function\r\n    - [x] typealias\r\n  - [x] Closures\r\n    - [x] weak self\r\n    - [x] trailing closures\r\n    - [x] implicit parameters\r\n  - [x] Unowned\r\n  - [x] Extensions on structs\r\n  - [x] Extensions to organize classes\r\n  - [x] Protocols on structs\r\n  - [x] Tuples\r\n  - [x] Trailing closures\r\n  - [ ] @Lazy\r\n  - [x] Pure Swift weak delegates via @class\r\n  - [x] Optionals\r\n    - [x] Implicitly unwrapped optionals\r\n  - [x] Convenience initializers\r\n  - [x] Class variables on structs\r\n  - [x] CConstPointer, CConstVoidPointer\r\n    - [x] withCString {}\r\n  - [x] UnsafePointer\r\n  - [x] sizeof()\r\n  - [x] Standard Protocols\r\n    - [x] Printable\r\n    - [x] BooleanType (aka LogicValue)\r\n    - [x] OutputStreamType\r\n    - [x] Equatable\r\n      - [x] Equatable on Enums with Associated Values\r\n    - [x] Hashable\r\n    - [x] SequenceType (GeneratorOf<T>)\r\n    - [x] Literal Convertibles\r\n      - [x] StringLiteralConvertible\r\n      - [x] IntegerLiteralConvertible\r\n  - [x] Left shift AND right shift\r\n  - [x] Enums on steroids\r\n    - [x] RawRepresentable\r\n  - [ ] Dynamic type system, reflection\r\n  - [x] Operator overloading\r\n  - [x] UCS-4 identifiers (üêîüêîüêî)\r\n  - [ ] ~~RTF source code with images and code sections in different fonts~~\r\n  - [x] Nested classes/types\r\n  - [ ] Patterns\r\n    - [x] Use wildcard pattern to ignore value\r\n  - [ ] @autoclosure\r\n  - [ ] unsafeBitCast (was reinterpretCast)\r\n  - [x] final\r\n  - [x] Nil coalescing operator\r\n  - [ ] dynamic\r\n\r\n###Why?!\r\n\r\nThis is an experiment to get acquainted with Swift. To check whether something\r\nreal can be implemented in 'pure' Swift. Meaning, without using any Objective-C\r\nCocoa classes (no NS'ism).\r\nOr in other words: Can you use Swift without writing all the 'real' code in\r\nwrapped Objective-C? :-)\r\n\r\n###Contact\r\n\r\n[@helje5](http://twitter.com/helje5) | helge@alwaysrightinstitute.com\r\n\r\n![](http://www.alwaysrightinstitute.com/ARI.png)\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}